---
title: "백준 물병 1052번"

categories:
  - CodingTest
 
tags:
   [비트마스킹]

date: 2024-09-26

toc: true
toc_sticky: true
sidebar_main: true
---

## <mark style = "background-color : #dcffe4"> 1. 문제

> 문제

지민이는 N개의 물병을 가지고 있다. 각 물병에는 물을 무한대로 부을 수 있다. <br>
처음에 모든 물병에는 물이 1리터씩 들어있다. 지민이는 이 물병을 또 다른 장소로 옮기려고 한다. <br>
지민이는 한 번에 K개의 물병을 옮길 수 있다. 하지만, 지민이는 물을 낭비하기는 싫고, <br>
이동을 한 번보다 많이 하기는 싫다. 따라서, 지민이는 물병의 물을 적절히 재분배해서,<br>
 K개를 넘지 않는 비어있지 않은 물병을 만들려고 한다.

물은 다음과 같이 재분배 한다.

먼저 같은 양의 물이 들어있는 물병 두 개를 고른다. <br>
그 다음에 한 개의 물병에 다른 한 쪽에 있는 물을 모두 붓는다. 이 방법을 필요한 만큼 계속 한다.

이런 제약 때문에, N개로 K개를 넘지않는 비어있지 않은 물병을 만드는 것이 불가능할 수도 있다. <br>
다행히도, 새로운 물병을 살 수 있다. 상점에서 사는 물병은 물이 1리터 들어있다.

예를 들어, N=3이고, K=1일 때를 보면, 물병 3개로 1개를 만드는 것이 불가능하다. <br>
한 병을 또다른 병에 부으면, 2리터가 들어있는 물병 하나와, 1리터가 들어있는 물병 하나가 남는다. <br>
만약 상점에서 한 개의 물병을 산다면, 2리터가 들어있는 물병 두 개를 만들 수 있고, <br>
마지막으로 4리터가 들어있는 물병 한 개를 만들 수 있다.

> 입력

첫째 줄에 N과 K가 주어진다. <br>
N은 107보다 작거나 같은 자연수이고, K는 1,000보다 작거나 같은 자연수이다.

> 출력

첫째 줄에 상점에서 사야하는 물병의 최솟값을 출력한다. 만약 정답이 없을 경우에는 -1을 출력한다.


## <mark style = "background-color : #dcffe4"> 2. 풀이과정 

> **설명**

문제의 조건에서 같은 양의 물이 들어있는 물병 두 개를 합쳐야 한다는 것, <BR>
모든 물병은 초기에 1L씩 들어있다는 것에서 물병은 항상 2의 제곱수만큼 들어있는 것을 알수있다.<br>
즉, 물이 들어있는 물병은 물병의 개수를 이진수로 표현했을 때 1의 개수가 된다.<br>

1의 개수가 k보다 작거나 같으면 물병이 추가로 필요하지 않지만,<br>
k보다 클 경우에는 최소한의 물병을 추가해야 한다.<br>
따라서 물병을 1부터 증가시키며 정답을 도출했다.

> **동작 과정**

	1. 기존 물병 + 추가 물병 수를 2진수로 변환해 1의 개수 도출
	2. 1번에서 도출한 수가 k보다 작거나 같을 경우 추가 물병 수 출력


### **- 정답 코드**

```c++
#include <iostream>
#include <bitset>
using namespace std;
int main()
{
	int n, k; cin >> n >> k;
	int cupCnt = 0;
	while (1)
	{
		int cnt = bitset<24>(n + cupCnt).count();
		if (cnt <= k)
		{
			cout << cupCnt;
			return 0;
		}
		cupCnt++;
	}
}
```


## <mark style = "background-color : #dcffe4"> 3. 결과

![image](https://github.com/user-attachments/assets/cedb2609-5aa4-4f46-af93-0b9ee82d68da)

> 6% 오답

**bitset 크기를 부족하게 지정한 것이 오답 원인** <br>
최대 10^7인 N보다 큰 최솟값인 2^24로 지정하여 해결.!

---


