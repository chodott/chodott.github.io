---
title: C++ 최적화 - 문자열 최적화

categories:
  - c++ 최적화
 
tags:
  - [c++]

date: 2024-07-25

toc: true
toc_sticky: true
sidebar_main: true
---

이 글은 작성자가 개인적으로 공부한 내용을 정리한 글입니다. <br>
따라서 사실과는 다른 내용이 포함될 수 있습니다.  <br>
잘못된 정보가 있다면 메일이나 댓글로 지적해주시면 정말 감사하겠습니다.
{: .notice--primary }

c++의 std::string은 c++ 표준 라이브러리에서 많이 사용하는 기능 중 하나이다.
문자열을 조작하는 코드는 자주 실행되기 때문에 최적화 대상으로 삼는다면 최고의 효과를 낼 수 있다.<br>

## <mark style = "background-color : #dcffe4"> 문자열의 문제점

### - 동적 할당
문자열은 필요한 만큼 메모리를 자동으로 할당 받아 편리하게 사용할 수 있다. <br>
문자열이 메모리를 할당 받는 과정은 다음과 같다. <br>
1. 기존 문자열에 새 문자나 문자열을 추가해 내부 버퍼의 크기를 초과한다.
2. 메모리 관리자에서 새 버퍼를 가져와 문자열을 새 버퍼에 복사한다.

std::string은 할당 과정에서의 비용을 절약하기 위해 필요한 문자열 길이보다 더 큰 공간을 할당한다.<br>
얼마나 공간을 할당할 지는 구현에 따라 달라진다. ex) 문자열 길이보다 큰 2의 거듭제곱 값으로 할당<br>
이 방법은 문자열의 길이를 늘려야 하는 경우가 발생해도 버퍼에 충분한 공간이 있어, 새 버퍼 할당이 불필요할 수 있다<br>
문자열이 길어질 수록 문자를 추가하는 비용이 상수에 가까워진다는 장점이 있으나, 사용되지 않는 공간이 낭비된다는 단점이 존재한다.

### - 값
문자열은 대입문과 표현식에서 값처럼 작동한다.<br>
즉 하나의 문자열을 다른 문자열에 대입할 때 복사 연산이 발생한다는 뜻이다. <br>
예를 들어 a1 = a2 + a3 + a4; (a1,a2,a3,a4는 모두 문자열) 문장에서는 <br>
s2 + s3 결과에서 임시 문자열이 새로 할당되고 s4를 연결하면 또 다른 임시 문자열 값이 된다. <br>
결과적으로 메모리 관리자를 많이 호출하게 되는 결과를 초래한다. <br>

## 문자열 최적화 시도

다음은 최적화 대상으로 정한 함수이다
시간 측정 시 한 번 호출하는 데 평균 70마이크로초가 걸린다.
```c++
string remove_ctrl(string s)
{
	string result;
	for(int i=0;i<s.length(); ++i)
	{
		if(s[i] >= 0x20) 
		result = result + s[i];
	}
	return result;
}
```


### 1. 내용 변경 연결 연산자 +=
- 코드<br>
```c++
string remove_ctrl(string s)
{
	string result;
	for(int i=0; i<s.length(); ++i)
	{
		if(s[i] >= 0x20)
		result += s[i]
	}
	return result;
}
```
- 결과 <br>
위 함수로 시간 측정을 한 결과 한 번 호출하는 데 평균 9.89 마이크로초가 걸렸다(약 8배 개선). <br>
연결 표현식의 결과를 저장하기 위해 문자열 객체를 할당하는 코드와 복사 및 삭제 연산을 제거한 결과이다.

---

### 2. 저장 공간 예약으로 재할당 줄이기
std::string의 reserve() 멤버 함수는 저장 공간을 미리 할당할 수 있다. <br>
reserve() 함수를 통해 추정한 문자열의 길이를 미리 할당한다면 버퍼 재할당 연산을 제거할 뿐 아니라, <br>
데이터의 캐시 지역성 또한 향상 시킬 수 있다.

- 코드 <br>
```c++
string remove_ctrl(string s)
{
	string result;
	result.reserve(s.length());
	for(int i=0; i<s.length(); ++i)
	{
		if(s[i] >= 0x20)
		result += s[i];
	}
	return result;
}
```

- 결과 <br>
reserve 함수를 적용하지 않은 것과 결과가 크게 다르지 않았다.<br>
문자열의 길이를 미리 할당해 재할당 연산을 제거하는 최적화 방법인데, <br>
예시로 사용한 문자열의 길이가 너무 짧은 것 같아 100글자로 늘려보았다.<br><br>
	reserve 함수 사용 X -> 35.76 마이크로초 <br>
	reserve 함수 사용 o -> 27.65 마이크로초 <br>
	약 20~30% 정도 속도 향상을 얻을 수 있었다. 

---

### 3. 문자열 인수의 복사 제거
우리의 최적화 대상 함수는 인자로 받는 문자열 s를 수정하지 않는다. <br>
따라서 const 참조를 사용해 할당 비용을 절약할 수 있다.

- 코드<br>
```c++
string remove_ctrl(string const& s)
{
	string result;
	result.reserve(s.length());
	for(int i=0; i<s.length(); ++i)
	{
		if(s[i] >= 0x20)
		result += s[i];
	}
	return result;
}
```
- 결과<br>
시간 측정 결과 평균 29.20마이크로초가 걸렸다. <br>
이후 몇 번 더 테스트를 거쳐도 평균 속도가 빨라지는 결과는 나타나지 않았다.<br><br>
최적화 과정을 거쳤음에도 속도가 오히려 느려진 경우는 다음과 같다.<br>
이전 함수에서는 s를 역참조할 필요가 없었다. 하지만 s가 참조형이 되어 역참조해야 할 필요성이 생겼다.<br>
결국 포인터를 역참조하는 비용 때문에 성능 저하가 발생한 것이다.

---

### 4. 반복자로 포인터 역참조 제거
문자열 반복자는 문자 버퍼를 가리키는 포인터인데, 이는 역참조 비용을 절약할 수 있다.
- 코드<br>
```c++
string remove_ctrl(string const& s)
{
	string result;
	result.reserve(s.length());
	for(auto it = s.begin(), end = s.end(); it != end; ++it)
	{
		if(*it >= 0x20)
		result += *it;
	}
	return result;
}
```
- 결과<br>
평균적으로 43.36 마이크로초가 소요된다.<br> 
놀랍게도 책의 내용과 다르게 효율이 두 배 정도 감소했다. <br>
????? 

---

### 5. 반환된 문자열의 복사 제거
다음 코드는 함수가 리턴될 때 호출자의 문자열 변수에 반환값을 저장하기 때문에 복사가 발생하지 않는다<br>
- 코드<br>
```c++
void remove_ctrl(string& result, string const& s)
{
	result.clear();
	result.reserve(s.length());
	for(auto it = s.begin(), end = s.end(); it != end; ++it)
	{
		if(*it >= 0x20)
		result += *it;
	}
}
```
- 결과<br>
평균적으로 40.55 마이크로초가 소요된다<br>
1% 정도의 속도 향상이 나타났다.

---
### 요약
전체적으로 내가 이해한 것과 동일하게 최적화 결과가 나타나고 있는데, <br>
반복자를 이용해 성능 저하 문제를 해결할 수 없었던 부분만 오차가 발생했다. <br>

다음 포스팅에 작성할 문자열 최적화 두번째 시도에서 방법을 찾을겸 반복자 복습을 진행해야겠다.


---
참고 <br>
커트 건서로스,「Optimized C++」, 옥찬호, 한빛미디어, 2019 <br>
{: .notice }
