---
title: C# - Class, Interface

categories:
  - C# 개념
 
tags:
  - [문법]

date: 2024-07-03

toc: true
toc_sticky: true
sidebar_main: true
---

이 글은 c++ 사용에 익숙한 작성자가 c#과 차이가 있는 부분에 대한 주관적인 의견을 담은 개인 정리 글입니다. <br>
따라서 사실과는 다른 내용이 포함될 수 있습니다. 잘못된 정보가 있다면 메일이나 댓글로 지적해주시면 감사하겠습니다.
{: .notice--primary }

## <mark style = "background-color : #dcffe4"> 정리

class로 정의된 형식은 참조 형식이다. 런타임에 참조 형식의 변수를 선언할 떄 변수는 new 연산자를 사용하여 <br>클래스의 인스턴스를 명시적으로 만들거나 다른 곳에서 생성될 수 있는 호환되는 형식의 개체를 할당하기 전까지 <br>null값을 포함한다.

개체가 생성되면 해당 개체가 관리되는 힙에 메모리가 할당되고 변수에는 개체 위치에 대한 참조만 포함된다. <br>
개체에서 사용하는 메모리는 Garbage Collection으로 자동 해제된다.

c#에서의 클래스는 c++과 다르게 access modifer 키워드를 작성해야 한다. <br>
문서 상에 class가 public으로 선언되면 누구나 이 클래스의 인스턴스를 생성할 수 있다는데, <br>
private으로 선언된다면 누가 인스턴스를 생성할 수 있는걸까? <br>
-> 조사해보니 외부 어셈블리에서 접근 할 수 없도록 클래스의 사용 범위를 명확하게 하는 용도인듯 하다. 


### 개체 생성
개체 생성은 c++과 형식이 동일하다.
다음과 같이 new 키워드와 클래스 이름을 사용하여 생성하거나

`Object object1 = new Object();`

다음과 같이 선언하는 것으로 개체를 생성하지 않고 참조 형식만 선언할 수 있다.

`Object object2`;

### 상속

문서 상에 c#의 클래스는 하나의 기본 클래스에서만 직접 상속할 수 있다고 적혀있다. <br>
정확히 이해하지 못한 것 같아 c#의 다중상속에 대해 찾아보았다.

**c#은 다중 상속이 제한되어있다**.
이유는 죽음의 다이아몬드 상속때문이라고 한다.

다음은 예시이다.<br>
base class가 같은 2개의 부모 클래스로부터 다중 상속받는 자식 클래스가 존재한다.<br>
2개의 부모 클래스가 base class에서 선언된 함수를 오버라이딩하고<br>
자식 클래스에서 동일한 함수를 사용하고자 하면 문제가 발생한다.

부모 클래스가 동일한 함수이나 구현부가 다른 함수를 가지고 있고, 자식 클래스가 오버라이딩 하지 않고 <br>
그대로 물려 받아 사용하면 두 부모 클래스 중 어떤 것을 사용해야할지 모호성이 발생하고 만다. <br>
이것이 죽음의 다이아몬드 상속 문제이다.

**하지만 interface는 다중 상속이 가능하다.**

### interface
- interface에는 class 또는 struct가 구현해야 하는 관련 기능 그룹에 대한 정의가 포함되어 있다. 

- 암묵적인 규칙에 따라 인터페이스 이름은 대문자 I로 시작한다.   
  ex) IGameObject

- Interface로 직접 객체를 생성할 수 없다. <br>
-> 인터페이스를 구현한 클래스나 구조체에 의해 생성된다.


멤버 변수나 다른 멤버 함수를 가질 수 없고 추상 함수만 가진다. -> 자식에게 자신만의 구현부를 상속하지 않는다. <br>
따라서 자식 클래스들은 반드시 오버라이딩을 해야하며, 다중 상속의 문제 죽음의 다이아몬드가 발생하지 않는다.

---
참고 <br>
백현우,「처음 배우는 C# 프로그래밍」, 위키북스, 2020 <br>
Microsoft Learn, "C# 제네릭", https://learn.microsoft.com/ko-kr/dotnet/csharp/, 2024.07.03 <br>
{: .notice }
